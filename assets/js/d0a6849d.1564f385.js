"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[354],{39579:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new Janitor class and is cached for later use. Janitor provides an option in case you want to name your Janitor for easier reference later.","params":[{"name":"name","desc":"","lua_type":"string?"}],"returns":[{"desc":"","lua_type":"_tasks: {[string]: any}"},{"desc":"","lua_type":"context: string"},{"desc":"","lua_type":"name: string?"},{"desc":"","lua_type":"index: number | string"},{"desc":"","lua_type":"__index: Janitor"}],"function_type":"static","since":"0.11","source":{"line":39,"path":"src/Features/Cleanup/Janitor.lua"}},{"name":"isJanitor","desc":"Returns true if the given class is a Janitor, if not it returns false.","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"static","since":"0.11","source":{"line":65,"path":"src/Features/Cleanup/Janitor.lua"}},{"name":"Give","desc":"**Example:**\\n```lua\\nlocal janitor = MapLib:GetFeature(\\"Cleanup\\").Janitor.new() -- Constructs new Janitor\\n\\nlocal part = Instance.new(\\"Part\\")\\npart.Anchored = true\\npart.Size = Vector3.new(1, 1, 1)\\npart.Parent = workspace\\n\\njanitor:Give(part)\\n\\ntask.wait(5)\\njanitor:Cleanup() -- Destroys the part \\n```\\n\\nThis method is used to give Janitor tasks to cleanup, these tasks can be anything, some examples include, functions, threads, coroutines or anything with a .Destroy function.\\n:::tip\\nJanitor allows for tables to be given in as an argument. If Janitor detects a table it will loop through the table and add anything it finds will be added to the tasks table.\\n\\n```lua\\nlocal janitor = MapLib:GetFeature(\\"Cleanup\\").Janitor.new() -- Constructs new Janitor\\n\\nlocal connection1 = RunService.Heartbeat:Connect(function() \\n\\tprint(\\"Running\\")\\nend)\\n\\nlocal connection2 = RunService.Heartbeat:Connect(function() \\n\\tprint(\\"Running\\")\\nend)\\n\\njanitor:Give({connection1, connection2})\\n\\ntask.wait(5)\\njanitor:Cleanup() -- Destroys both connections\\n```\\n:::\\n:::caution\\nJanitor does not have the ability to completly clear references if they are defined to a variable.\\nTo initate proper garbage collection using Janitor we recommend setting the variable to `reference = janitor:Give(task)` which will set the reference to nil.\\n\\n```lua\\nlocal janitor = MapLib:GetFeature(\\"Cleanup\\").Janitor.new() -- Constructs new Janitor\\n\\nlocal part = Instance.new(\\"Part\\")\\npart.Anchored = true\\npart.Size = Vector3.new(1, 1, 1)\\npart.Parent = workspace\\n\\npart = janitor:Give(part)\\n--Since :Give returns nil we can lose the reference and initate proper garbage collection.\\n\\ntask.wait(5)\\njanitor:Cleanup() -- Destroys the part and initates garbage collection\\n```\\n:::","params":[{"name":"task","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"nil"}],"function_type":"method","since":"0.11","source":{"line":132,"path":"src/Features/Cleanup/Janitor.lua"}},{"name":"Cleanup","desc":"Calls for the Janitor to cleanup up all the tasks it was given.","params":[],"returns":[{"desc":"","lua_type":"nil"}],"function_type":"method","since":"0.11","source":{"line":165,"path":"src/Features/Cleanup/Janitor.lua"}},{"name":"Destroy","desc":"Completely destroys Janitor and all references to it. If the Janitor has tasks then those tasks are cleaned up.","params":[],"returns":[{"desc":"","lua_type":"nil"}],"function_type":"method","since":"0.11","source":{"line":207,"path":"src/Features/Cleanup/Janitor.lua"}}],"properties":[],"types":[],"name":"Janitor","desc":"This is an external class which can be referenced with `MapLib:GetFeature(\\"Cleanup\\").Janitor`\\n\\nJanitor is destructor based class designed to assist with clearing up connections and events.\\n:::warning\\n    WARNING! This is an advanced feature.\\n    This page assumes you are familiar, comfortable and can write Luau code.\\n:::","tags":["Advanced Feature"],"source":{"line":25,"path":"src/Features/Cleanup/Janitor.lua"}}')}}]);